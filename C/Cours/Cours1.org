#+TITLE: COURS 1 - Les bases du langage C
#+AUTHOR: Lena SAVY-LARIGALDIE

Formateur : Paul ERNEST

* TABLE OF CONTENT :toc:
- [[#environement-de-travail][ENVIRONEMENT DE TRAVAIL]]
  - [[#installation-des-outils][INSTALLATION DES OUTILS]]
  - [[#cl-equivalent-de-make-sur-windows][CL (equivalent de make sur windows)]]
  - [[#cmake][CMAKE]]
- [[#etapes-de-la-realisation-dun-programme][ETAPES DE LA REALISATION D'UN PROGRAMME]]
  - [[#developpement][Developpement]]
  - [[#compilation][Compilation]]
  - [[#linkage][Linkage]]
  - [[#execution][Execution]]
- [[#3-types-derreur][3 TYPES D'ERREUR]]
- [[#debug--release][DEBUG & RELEASE]]
- [[#structure-dun-programme][STRUCTURE D'UN PROGRAMME]]
- [[#pourquoi-le-langage-c-][POURQUOI LE LANGAGE C ?]]
- [[#codages-numeriques][CODAGES NUMERIQUES]]
- [[#variables-et-premieres-instructions][VARIABLES ET PREMIERES INSTRUCTIONS]]
  - [[#ram-random-acces-memory][RAM (Random Acces Memory)]]
  - [[#les-tailles-en-binaire][Les tailles en binaire]]
  - [[#variable][Variable]]
  - [[#regles-de-nommage][Regles de nommage]]
  - [[#syntaxe][Syntaxe]]
  - [[#bases-numeriques][Bases numeriques]]
  - [[#constantes][Constantes]]
  - [[#valeurs-negative][Valeurs negative]]
  - [[#flottant][Flottant]]
- [[#operateurs][OPERATEURS]]
  - [[#operateurs-arithmetiques][Operateurs arithmetiques]]
  - [[#operateurs-de-comparaison][Operateurs de comparaison]]
  - [[#operateurs-logiques][Operateurs logiques]]
  - [[#operateurs-daffectation][Operateurs d'affectation]]
  - [[#operateur-ternaire][Operateur ternaire]]
- [[#entreesortie][ENTREE/SORTIE]]
  - [[#insertion-scanf][Insertion (scanf)]]
  - [[#affichage-printf][Affichage (printf)]]
- [[#les-fonctions][LES FONCTIONS]]
  - [[#les-fonctions-en-3-etapes][LES FONCTIONS EN 3 ETAPES]]
  - [[#les-fonctions-void][LES FONCTIONS VOID]]
  - [[#recursivite][RECURSIVITE]]
- [[#les-structures-conditionnelles][LES STRUCTURES CONDITIONNELLES]]
  - [[#if-else-else-if][IF, ELSE, ELSE IF]]
- [[#lexique][LEXIQUE]]

* ENVIRONEMENT DE TRAVAIL

** INSTALLATION DES OUTILS

*** CMake

Metalanguage

Permet de generer une chaine de compilation.

- Installer CMake (cmake.org)
- Lors de l'installation, ajouter la variable d'environnement (System PATH)

*** Visual Studio Community

IDE

- Installer Visual Studio Community
- Lors de l'installation, cocher la suite Developpement C/C++.
- Ajouter =cl= aux variables d'environement.
  
** CL (equivalent de make sur windows)

*** Compilation

Creer un fichier objet de =HelloWorld.c= en =HelloWorld.obj= .
Cree aussi un executable =HelloWorld.exe= .

#+begin_src
cl HelloWorld.c
#+end_src

*** Execution

Executer l'application =HelloWorld.exe= .

#+begin_src
HelloWorld.exe
#+end_src

*** Recompiler

*IMPORTANT!* Il est important de recompiler le code apres chaque modification afin de verifier le bon fonctionnement.


** CMAKE

Cree un environement pour developper sur n'importe quel systeme d'exploitation.

*** CMakeLists.txt

Fichier de configuration minimaliste.

#+begin_src
cmake_minimum_required(VERSION 3.14)

project(Projet_Langage_C)

set(CMAKE_C_STANDARD 11)

add_executable(HelloWorld HelloWorld.c)
#+end_src

Le code ci-dessus :
- Choisit la version de CMake
- Choisit le nom du projet
- Choisit le langage
- Choisit le nom de l'executable et le fichier source

*** Dossier build

Creer un dossier =build= .

*** Generer le projet

[[https://raw.githubusercontent.com/Plunne/siilena/main/C/Cours/images/cmake1.PNG]]

*** Ouvrir le projet dans Visual Studio

Les projets Visual Studio ont comme extension =.slm= .

Aller dans le dossier build et lancer avec Visual Studio le fichier =Projet_Langage_C.sln= .


* ETAPES DE LA REALISATION D'UN PROGRAMME 

=(1) DEVELOPPEMENT= -> =(2) COMPILATION= -> =(3) LINKAGE= -> =(4) EXECUTION=

** Developpement

Developpement du programme en code interpretable par l'humain.

** Compilation

Convertir le code interpretable (ASM, C, C++, etc.) en un code machine (binaire, fichiers objet ".o").

** Linkage

Cherche les fichiers objets contenant les fonctions externes utlisees dans le programme.

** Execution

Application executable.

* 3 TYPES D'ERREUR

- Erreur de code
- Erreur de compilation
- Erreur de linkage

* DEBUG & RELEASE

*** Debug

Le mode Debug permet de debugguer l'executable. Pour cela, l'executable doit contenir les informations supplementaires necessaires au debug et donc l'executable est plus lourd.

*** Release

A contrariot, le mode release ne permet pas de debugguer, en revanche ne contenant pas les informations de debug il est beaucoup leger.
C'est le mode que l'on utilise pour le deploiement final de notre executable car plus optimise.

* STRUCTURE D'UN PROGRAMME

*** Inclusions

Importation de fichiers d'en-tete. Ces fichiers contiennent des declarations de fonctions et variables externes.

*** Declaration de fonction 

Prototype de fonction.

*** La fonction main()

Entree du programme.

- Il y en a *obligatoirement 1!*
- Il faut une accolade ouvrant et une fermante.

*** Accolades, blocs d'instructions

Les instructions se codent dans des accolades.

*** Declaration de variable

Allocation memoire pour stocker une valeur et attribution de son alias.

*** Definition de fonction

Portion de code independante (sous-programme).

*** Commentaires

Code non interprete a la compilation aidant a la comprehension d'un programme.

* POURQUOI LE LANGAGE C ?

A venir...

* CODAGES NUMERIQUES

A venir...

* VARIABLES ET PREMIERES INSTRUCTIONS

** RAM (Random Acces Memory)

Partie de la memoire de l'ordinateur ou l'on peut stocker des informations temporaires (variables par exemple).
Decompose en adresses.

** Les tailles en binaire

Voir Memo 2 - Les Types en C.

** Variable

Une variable est un emplacement memoire reserve pour stocker une valeur.

** Regles de nommage

- Lettres et Chiffres uniquement
- Commence par une lettre minuscule
- Sensible a la casse (Majuscule != Minuscule)
- Pas de mot cle

** Syntaxe

#+begin_src c
type nom = valeur;
#+end_src

** Bases numeriques

Prefixes des bases numeriques lors de l'affectation d'une variable.

- Decimal (par defaut) : =0d=
- Hexadecimal : =0x=
- Binaire : =0b=
- Octal : =0=

** Constantes

*** Constantes symboliques

Evite de declarer une variable pour une valeur reutilisee qui ne changera pas a l'execution.

#+begin_src c
#define NOM valeur 
#+end_src

*** Constantes litterales

Empeche la modification.

- Pour la securite, s'assurer que personne puisse l'affecter.
- Par convention, pour ameliorer la comprehension du code.

#+begin_src c
const type nom = valeur;
#+end_src

/Une constante symbolique prendra moins de place dans la pile mais en prendra plus dans le fichier objet
 tandis qu'une constante litterale prendra plus de place dans la pile mais n'en prendra moins dans le fichier objet./ 

** Valeurs negative

Pour un char :

=0= -> =127= -> =-128= -> =-1=

** Flottant

- 1 bit - Signe : Positif ou Negatif
- 8 bits - Exposant : Valeur de l'exposant de la puissance 10 (emplacement de la virgule)
- 23 bits - Mantisse : Valeur a afficher

* OPERATEURS

** Operateurs arithmetiques

*** Classiques

- Addition : =+=
- Soustraction : =-=
- Multiplication : =*=
- Division : =/=
- Modulo : =%=

*** Incrementation/Decrementation
  
**** Incrementation :

=i++= -> instruction puis i+1

=++i= -> i+1 puis instruction

**** Decremenation :

=i--= -> instruction puis i-1

=--i= -> i-1 puis instruction 

**** Exemple :

#+begin_src c
int a, b;
a = b = 5;
printf("%d %d", --i, i--);
printf("%d %d", --i, i--);
printf("%d %d", --i, i--);
printf("%d %d", --i, i--);
printf("%d %d", --i, i--);
#+end_src

-> =5 4=

a=4, b=4

-> =4 3=

a=3, b=3

-> =3 2=

a=2, b=2

-> =2 1=

a=1, b=1

-> =1 0=

a=0, b=0

*** Hierarchie des operateurs

1. Incrementation, Decrementation
2. Produit, Division, Modulo
3. Addition, Soustraction

** Operateurs de comparaison

Operateurs pour comparer 2 valeurs.

Retourne =1= si la comparaison est *vraie* sinon retourne =0= .

*** Inferieur/Superieur

- Inferieur : ~<~
- Superieur : ~>~
- Inferieur ou egal : ~<=~
- Superieur ou egal : ~>=~

*** Egalite/Difference

- Egalite : ~==~
- Difference : ~!=~

*** ET & OU Logique

Operateurs logiques permettant de comparer 2 condtions.

- ET : ~&&~ (SI *les 2 conditions* sont vraies ALORS retourne 1)
- OU : ~||~ (SI *au moins une* condition est vraie ALORS retourne 1)

*** NON Logique

Retourne =1= si la condtion est fausse ou le resultat ~=0~ .

- NON : ~!~

** Operateurs logiques

** Operateurs d'affectation

Affecte une variable en realisant une operation sur elle meme.

- Addition : ~+=~
- Soustraction : ~-=~
- Multiplication : ~*=~
- Division : ~/=~
- Modulo : ~%=~

** Operateur ternaire

=variable= = =expression= ? =si= : =sinon=

#+begin_src c
z = (x > y) ? x : y
#+end_src

Equivaut a :
#+begin_src c
if (x > y)
    z=x;
else
    z=y;
#+end_src

* ENTREE/SORTIE

** Insertion (scanf)

Inserer des valeurs.

*Exemple :*

#+begin_src c
int variable1, variable2;               // Declaration de 2 variables
scanf("%d %d", &variable1, &variable2); // Insersion de la valeur de chaque variable au clavier 
#+end_src

** Affichage (printf)

Afficher du texte et/ou des valeurs.

*Exemple :*

- En reprennant les 2 variables que l'on a insere ci-dessus.
- En admettant que nous avons insere les valeurs =10= puis =20= .

#+begin_src c
printf("Deux nombres : %d %d", variable1, variable2); // Affichage des 2 variables
#+end_src

-> =Deux nombres : 10 20= 

* LES FONCTIONS

Les fonctions sont des portions de code independantes (Sous-programmes).

/main(), printf() et scanf() sont des fonctions./ 

** LES FONCTIONS EN 3 ETAPES

=(1) Declaration= -> =(2) Definition= -> =(3) Appel=

*** Declaration

Creation du prototype qui determine :

- Le Nom
- Le Type de sa valeur de retour
- Les parametres qu'elle prendra

#+begin_src c
type_retour nomFonction(type_arg1 arg1, ..., type_arg2 arg2);
#+end_src

*** Definition

Implementation du code de la fonction.

#+begin_src c
type_retour nomFonction(type_arg1 arg1, ..., type_arg2 arg2)
{
    /* Instructions */

    return valeur_retour; // Valeur de retour de meme type que la fonction (ici : type_retour)
}
#+end_src

*** Appel

Utilisation de la fonction.

/Elles doivent imperativement affecter un emplacement memoire du meme type qu'elles./

#+begin_src c
type_retour variable = nomFonction(argument1, ..., argument2);
#+end_src

** LES FONCTIONS VOID

Les fonctions void sont des fonctions qui ne retournent aucune valeur, elle servent uniquement a executer des instructions.

*** Declaration

#+begin_src c
void nomFonction(type_arg1 arg1, ..., type_arg2 arg2);
#+end_src

*** Definition

Il n'y a donc pas besoin de retourner une valeur.

#+begin_src c
void nomFonction(type_arg1 arg1, ..., type_arg2 arg2)
{
    /* Instructions */
}
#+end_src

Mais il arrive cependant des fois ou l'on souhaite forcer la sortie d'une fonction void.

#+begin_src c
void nomFonction(type_arg1 arg1, ..., type_arg2 arg2)
{
    /* Instructions */

    return; // Alors dans ce cas on fait un return sans aucune valeur
}
#+end_src

*** Appel

Utilisation de la fonction.

/Elles s'utilisent seules et ne peuvent affecter un emplacement memoire./

#+begin_src c
nomFonction(argument1, ..., argument2);
#+end_src

** RECURSIVITE

Les fonctions recurrentes : fonction qui s'appelle elle-meme.

*IMPORTANT!* Dans une fonction recurrente il faut une condition d'arret.

*** Exemple :

   #+begin_src c
   float recurrence(int n) {
      if (n == 0) return 1;         // Condition d'arret
      return n * recurrence(--1);   // Recurrence
   }
   #+end_src

*** Avec operateur ternaire :

   #+begin_src c
   float recurrence(int n) {
      return (n == 0) ? 1 : n * recurrence(--n);
   }
   #+end_src

* LES STRUCTURES CONDITIONNELLES

** IF, ELSE, ELSE IF

*** IF

*SI* expression *ALORS* instructions

#+begin_src c
if (expression)
{
    // instructions
}
#+end_src

*** ELSE

*SI* expression *ALORS* instructions
*SINON* instructions

#+begin_src c
if (expression)
{
    // instructions
}
else
{
    // instructions
}
#+end_src

*** ELSE IF

*SI* expression *ALORS* instructions
*SINON SI* expression *ALORS* instructions
*SINON* instructions

#+begin_src c
if (expression)
{
    // instructions
}
else if (expression)
{
    // instructions
}
else
{
    // instructions
}
#+end_src

* LEXIQUE

- API : Ensemble d'outils qui permettent de faire l'interface avec un service.
- IDE : Integrated Development Environnement (Environnement de Developpement Integre : Editeur de code avec Debogueur, Compilateur et plein d'outils, c'est notre environement de travail)
