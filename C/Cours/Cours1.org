#+TITLE: COURS 1 - Les bases du langage C
#+AUTHOR: Lena SAVY-LARIGALDIE

Formateur : Paul ERNEST

* TABLE OF CONTENT :toc:
- [[#environement-de-travail][ENVIRONEMENT DE TRAVAIL]]
  - [[#installation-des-outils][INSTALLATION DES OUTILS]]
  - [[#cl-equivalent-de-make-sur-windows][CL (equivalent de make sur windows)]]
  - [[#cmake][CMAKE]]
- [[#etapes-de-la-realisation-dun-programme][ETAPES DE LA REALISATION D'UN PROGRAMME]]
  - [[#developpement][Developpement]]
  - [[#compilation][Compilation]]
  - [[#linkage][Linkage]]
  - [[#execution][Execution]]
- [[#3-types-derreur][3 TYPES D'ERREUR]]
- [[#debug--release][DEBUG & RELEASE]]
  - [[#debug][Debug]]
  - [[#release][Release]]
- [[#structure-dun-programme][STRUCTURE D'UN PROGRAMME]]
  - [[#inclusions][Inclusions]]
  - [[#declaration-de-fonction][Declaration de fonction]]
  - [[#la-fonction-main][La fonction main()]]
  - [[#accolades-blocs-dinstructions][Accolades, blocs d'instructions]]
  - [[#declaration-de-variable][Declaration de variable]]
  - [[#definition-de-fonction][Definition de fonction]]
  - [[#commentaires][Commentaires]]
- [[#pourquoi-le-langage-c-][POURQUOI LE LANGAGE C ?]]
- [[#codages-numeriques][CODAGES NUMERIQUES]]
- [[#variables-et-premieres-instructions][VARIABLES ET PREMIERES INSTRUCTIONS]]
  - [[#ram-random-acces-memory][RAM (Random Acces Memory)]]
  - [[#les-tailles-en-binaire][Les tailles en binaire]]
  - [[#variable][Variable]]
  - [[#regles-de-nommage][Regles de nommage]]
  - [[#syntaxe][Syntaxe]]
  - [[#bases-numeriques][Bases numeriques]]
  - [[#constantes][Constantes]]
  - [[#valeurs-negative][Valeurs negative]]
  - [[#flottant][Flottant]]
- [[#operateurs][OPERATEURS]]
  - [[#operateurs-arithmetiques][Operateurs arithmetiques]]
  - [[#operateurs-de-comparaison][Operateurs de comparaison]]
  - [[#operateurs-logiques][Operateurs logiques]]
  - [[#operateurs-daffectation][Operateurs d'affectation]]
  - [[#operateur-ternaire][Operateur ternaire]]
- [[#chaines-de-caracteres][CHAINES DE CARACTERES]]
  - [[#table-ascii][Table ASCII]]
  - [[#caracteres-de-controle][Caracteres de controle]]
  - [[#echappement-de-caractere][Echappement de caractere]]
  - [[#specificateurs-de-conversion][Specificateurs de conversion]]
- [[#entreesortie][ENTREE/SORTIE]]
  - [[#insertion-scanf][Insertion (scanf)]]
  - [[#affichage-printf][Affichage (printf)]]
  - [[#affichage-puts][Affichage (puts)]]
- [[#les-tableaux][LES TABLEAUX]]
  - [[#a-simple-dimension][A simple dimension]]
  - [[#a-double-dimensions][A double dimensions]]
- [[#les-fonctions][LES FONCTIONS]]
  - [[#les-fonctions-en-3-etapes][LES FONCTIONS EN 3 ETAPES]]
  - [[#les-fonctions-void][LES FONCTIONS VOID]]
  - [[#recursivite][RECURSIVITE]]
- [[#les-structures-conditionnelles][LES STRUCTURES CONDITIONNELLES]]
  - [[#if-else-else-if][IF, ELSE, ELSE IF]]
  - [[#break][BREAK]]
  - [[#switch][SWITCH]]
- [[#les-boucles-conditionnelles][LES BOUCLES CONDITIONNELLES]]
  - [[#while][WHILE]]
  - [[#do-while][DO WHILE]]
  - [[#for][FOR]]
  - [[#break-1][BREAK]]
  - [[#les-boucles-infinies][LES BOUCLES INFINIES]]
- [[#les-pointeurs][LES POINTEURS]]
  - [[#declaration][Declaration]]
  - [[#valeur-de-la-variable][Valeur de la variable]]
  - [[#adresse-de-la-variable][Adresse de la variable]]
  - [[#adresse-du-pointeur][Adresse du pointeur]]
  - [[#incrementation][Incrementation]]
  - [[#equivalence-avec-les-crochets-de-tableau][Equivalence avec les crochets de tableau]]
  - [[#soustraction-dadresses][Soustraction d'adresses]]
- [[#portee-des-variables][PORTEE DES VARIABLES]]
  - [[#variables-globales][Variables Globales]]
  - [[#variables-locales][Variables Locales]]
  - [[#variables-externes][Variables Externes]]
- [[#allocation-dynamique][ALLOCATION DYNAMIQUE]]
  - [[#malloc][Malloc]]
  - [[#free][Free]]
- [[#lexique][LEXIQUE]]

* ENVIRONEMENT DE TRAVAIL

** INSTALLATION DES OUTILS

*** CMake

Metalanguage

Permet de generer une chaine de compilation.

- Installer CMake (cmake.org)
- Lors de l'installation, ajouter la variable d'environnement (System PATH)

*** Visual Studio Community

IDE

- Installer Visual Studio Community
- Lors de l'installation, cocher la suite Developpement C/C++.
- Ajouter =cl= aux variables d'environement.
  
** CL (equivalent de make sur windows)

*** Compilation

Creer un fichier objet de =HelloWorld.c= en =HelloWorld.obj= .
Cree aussi un executable =HelloWorld.exe= .

#+begin_src
cl HelloWorld.c
#+end_src

*** Execution

Executer l'application =HelloWorld.exe= .

#+begin_src
HelloWorld.exe
#+end_src

*** Recompiler

*IMPORTANT!* Il est important de recompiler le code apres chaque modification afin de verifier le bon fonctionnement.


** CMAKE

Cree un environement pour developper sur n'importe quel systeme d'exploitation.

*** CMakeLists.txt

Fichier de configuration minimaliste.

#+begin_src
cmake_minimum_required(VERSION 3.14)

project(Projet_Langage_C)

set(CMAKE_C_STANDARD 11)

add_executable(HelloWorld HelloWorld.c)
#+end_src

Le code ci-dessus :
- Choisit la version de CMake
- Choisit le nom du projet
- Choisit le langage
- Choisit le nom de l'executable et le fichier source

*** Dossier build

Creer un dossier =build= .

*** Generer le projet

[[https://raw.githubusercontent.com/Plunne/siilena/main/C/Cours/images/cmake1.PNG]]

*** Ouvrir le projet dans Visual Studio

Les projets Visual Studio ont comme extension =.slm= .

Aller dans le dossier build et lancer avec Visual Studio le fichier =Projet_Langage_C.sln= .


* ETAPES DE LA REALISATION D'UN PROGRAMME 

=(1) DEVELOPPEMENT= -> =(2) COMPILATION= -> =(3) LINKAGE= -> =(4) EXECUTION=

** Developpement

Developpement du programme en code interpretable par l'humain.

** Compilation

Convertir le code interpretable (ASM, C, C++, etc.) en un code machine (binaire, fichiers objet ".o").

** Linkage

Cherche les fichiers objets contenant les fonctions externes utlisees dans le programme.

** Execution

Application executable.

* 3 TYPES D'ERREUR

- Erreur de code
- Erreur de compilation
- Erreur de linkage

* DEBUG & RELEASE

** Debug

Le mode Debug permet de debugguer l'executable. Pour cela, l'executable doit contenir les informations supplementaires necessaires au debug et donc l'executable est plus lourd.

** Release

A contrariot, le mode release ne permet pas de debugguer, en revanche ne contenant pas les informations de debug il est beaucoup leger.
C'est le mode que l'on utilise pour le deploiement final de notre executable car plus optimise.

* STRUCTURE D'UN PROGRAMME

** Inclusions

Importation de fichiers d'en-tete. Ces fichiers contiennent des declarations de fonctions et variables externes.

** Declaration de fonction 

Prototype de fonction.

** La fonction main()

Entree du programme.

- Il y en a *obligatoirement 1!*
- Il faut une accolade ouvrant et une fermante.

** Accolades, blocs d'instructions

Les instructions se codent dans des accolades.

** Declaration de variable

Allocation memoire pour stocker une valeur et attribution de son alias.

** Definition de fonction

Portion de code independante (sous-programme).

** Commentaires

Code non interprete a la compilation aidant a la comprehension d'un programme.

* POURQUOI LE LANGAGE C ?

- Souple et Puissant
- Facile a porter d'une plateforme a l'autre
- Syntaxe legere (contient peu de mots-cles)
- Langage modulaire

* CODAGES NUMERIQUES

A venir...

* VARIABLES ET PREMIERES INSTRUCTIONS

** RAM (Random Acces Memory)

Partie de la memoire de l'ordinateur ou l'on peut stocker des informations temporaires (variables par exemple).
Decompose en adresses.

** Les tailles en binaire

Voir Memo 2 - Les Types en C.

** Variable

Une variable est un emplacement memoire reserve pour stocker une valeur.

** Regles de nommage

- Lettres et Chiffres uniquement
- Commence par une lettre minuscule
- Sensible a la casse (Majuscule != Minuscule)
- Pas de mot cle

** Syntaxe

#+begin_src c
type nom = valeur;
#+end_src

** Bases numeriques

Prefixes des bases numeriques lors de l'affectation d'une variable.

- Decimal (par defaut) : =0d=
- Hexadecimal : =0x=
- Binaire : =0b=
- Octal : =0=

** Constantes

*** Constantes symboliques

Evite de declarer une variable pour une valeur reutilisee qui ne changera pas a l'execution.

#+begin_src c
#define NOM valeur 
#+end_src

*** Constantes litterales

Empeche la modification.

- Pour la securite, s'assurer que personne puisse l'affecter.
- Par convention, pour ameliorer la comprehension du code.

#+begin_src c
const type nom = valeur;
#+end_src

/Une constante symbolique prendra moins de place dans la pile mais en prendra plus dans le fichier objet
 tandis qu'une constante litterale prendra plus de place dans la pile mais n'en prendra moins dans le fichier objet./ 

** Valeurs negative

Pour un char :

=0= -> =127= -> =-128= -> =-1=

** Flottant

- 1 bit - Signe : Positif ou Negatif
- 8 bits - Exposant : Valeur de l'exposant de la puissance 10 (emplacement de la virgule)
- 23 bits - Mantisse : Valeur a afficher

* OPERATEURS

** Operateurs arithmetiques

*** Classiques

- Addition : =+=
- Soustraction : =-=
- Multiplication : =*=
- Division : =/=
- Modulo : =%=

*** Incrementation/Decrementation
  
**** Incrementation :

=i++= -> instruction puis i+1

=++i= -> i+1 puis instruction

**** Decremenation :

=i--= -> instruction puis i-1

=--i= -> i-1 puis instruction 

**** Exemple :

#+begin_src c
int a, b;
a = b = 5;
printf("%d %d", --i, i--);
printf("%d %d", --i, i--);
printf("%d %d", --i, i--);
printf("%d %d", --i, i--);
printf("%d %d", --i, i--);
#+end_src

-> =5 4=

a=4, b=4

-> =4 3=

a=3, b=3

-> =3 2=

a=2, b=2

-> =2 1=

a=1, b=1

-> =1 0=

a=0, b=0

*** Hierarchie des operateurs

1. Incrementation, Decrementation
2. Produit, Division, Modulo
3. Addition, Soustraction

** Operateurs de comparaison

Operateurs pour comparer 2 valeurs.

Retourne =1= si la comparaison est *vraie* sinon retourne =0= .

*** Inferieur/Superieur

- Inferieur : ~<~
- Superieur : ~>~
- Inferieur ou egal : ~<=~
- Superieur ou egal : ~>=~

*** Egalite/Difference

- Egalite : ~==~
- Difference : ~!=~

*** ET & OU Logique

Operateurs logiques permettant de comparer 2 condtions.

- ET : ~&&~ (SI *les 2 conditions* sont vraies ALORS retourne 1)
- OU : ~||~ (SI *au moins une* condition est vraie ALORS retourne 1)

*** NON Logique

Retourne =1= si la condtion est fausse ou le resultat ~=0~ .

- NON : ~!~

** Operateurs logiques

** Operateurs d'affectation

Affecte une variable en realisant une operation sur elle meme.

- Addition : ~+=~
- Soustraction : ~-=~
- Multiplication : ~*=~
- Division : ~/=~
- Modulo : ~%=~

** Operateur ternaire

=variable= = =expression= ? =si= : =sinon=

#+begin_src c
z = (x > y) ? x : y
#+end_src

Equivaut a :
#+begin_src c
if (x > y)
    z=x;
else
    z=y;
#+end_src

* CHAINES DE CARACTERES

A Venir...

** Table ASCII

A Venir...

** Caracteres de controle

Les ordres de controle sont des caracteres predefinis pour controler des chaines de caracteres.

| Caractere | Utilite                                    |
|-----------+--------------------------------------------|
| ~\n~        | Retour a la ligne                          |
| ~\t~        | Tabulation                                 |
| ~\b~        | Retour arriere (Backspace)                 |
| ~\0~        | Fin de chaine                              |
| ~\r~        | Retour chariot (deplace en debut de ligne) |

** Echappement de caractere

Les caracteres speciaux relatifs aux chaines doivent etre echapes avec un ~\~ .

| Caractere | Caractere a afficher    | Affiche |
|-----------+-------------------------+---------|
| ~\\~        | Antislash               | ~\~       |
| ~\"~     | Guillemet               | ="=              |
| ='=         | Apostrophe              | ='=              |
| ~\?~        | Point d'interrogation   | ~?~       |

** Specificateurs de conversion



* ENTREE/SORTIE

** Insertion (scanf)

Inserer des valeurs.

*Exemple :*

#+begin_src c
int variable1, variable2;               // Declaration de 2 variables
scanf("%d %d", &variable1, &variable2); // Insersion de la valeur de chaque variable au clavier 
#+end_src

** Affichage (printf)

Afficher du texte et/ou des valeurs.

*Exemple :*

- En reprennant les 2 variables que l'on a insere ci-dessus.
- En admettant que nous avons insere les valeurs =10= puis =20= .

#+begin_src c
printf("Deux nombres : %d %d", variable1, variable2); // Affichage des 2 variables
#+end_src

-> =Deux nombres : 10 20= 

** Affichage (puts)

Pour afficher seulement du texte, puts est preferable car :

- Utilise moins de ressources
- Retour a la ligne automatique

Cependant il n'accepte pas de valeurs en arguments.

#+begin_src c
puts("Chaine de texte uniquement.");
#+end_src

* LES TABLEAUX

Un tableau contient des elements d'un type definit.


** A simple dimension

*** Declaration

Creation d'un tableau

*A l'initialisation il faut imperativement une valeur constante (qui ne doit pas changer)!*

#+begin_src c
type tableau[TAILLE];
#+end_src

*** Affectation a l'initialisation

#+begin_src c
type tableau[TAILLE] = { valeur0, valeur1, valeur2, ... };
#+end_src

*** Index

#+begin_src c
tableau[index];
#+end_src

*** Affectation a l'index

#+begin_src c
tableau[index] = valeur;
#+end_src

** A double dimensions

Un tableau qui contient 2 dimensions.

*** Declaration

Creation d'un tableau a 2 dimensions

*Tous comme le simple dimension, a l'initialisation il faut imperativement une valeur constante (qui ne doit pas changer)!*

#+begin_src c
type tableau[NOMBRE_LIGNES][NOMBRE_COLONNES];
#+end_src

*** Affectation a l'initialisation

En prennant pour exemple un tableau a 2 lignes et 3 colonnes.

#+begin_src c
type tableau[2][3] = { valeur00, valeur01, valeur02, valeur10, valeur11, valeur12 };
#+end_src

L'ideal reste tout de meme d'initialiser avec une 2 boucles for imbriquees.

*** Index

#+begin_src c
tableau[x][y];
#+end_src


*** Affectation a l'index

#+begin_src c
tableau[x][y] = valeur;
#+end_src

*** Passer de double dimension a simple dimension

=Ligne= * =Taille de la ligne= + =Colonne=

* LES FONCTIONS

Les fonctions sont des portions de code independantes (Sous-programmes).

/main(), printf() et scanf() sont des fonctions./ 

** LES FONCTIONS EN 3 ETAPES

=(1) Declaration= -> =(2) Definition= -> =(3) Appel=

*** Declaration

Creation du prototype qui determine :

- Le Nom
- Le Type de sa valeur de retour
- Les parametres qu'elle prendra

#+begin_src c
type_retour nomFonction(type_arg1 arg1, ..., type_arg2 arg2);
#+end_src

*** Definition

Implementation du code de la fonction.

#+begin_src c
type_retour nomFonction(type_arg1 arg1, ..., type_arg2 arg2)
{
    /* Instructions */

    return valeur_retour; // Valeur de retour de meme type que la fonction (ici : type_retour)
}
#+end_src

*** Appel

Utilisation de la fonction.

/Elles doivent imperativement affecter un emplacement memoire du meme type qu'elles./

#+begin_src c
type_retour variable = nomFonction(argument1, ..., argument2);
#+end_src

** LES FONCTIONS VOID

Les fonctions void sont des fonctions qui ne retournent aucune valeur, elle servent uniquement a executer des instructions.

*** Declaration

#+begin_src c
void nomFonction(type_arg1 arg1, ..., type_arg2 arg2);
#+end_src

*** Definition

Il n'y a donc pas besoin de retourner une valeur.

#+begin_src c
void nomFonction(type_arg1 arg1, ..., type_arg2 arg2)
{
    /* Instructions */
}
#+end_src

Mais il arrive cependant des fois ou l'on souhaite forcer la sortie d'une fonction void.

#+begin_src c
void nomFonction(type_arg1 arg1, ..., type_arg2 arg2)
{
    /* Instructions */

    return; // Alors dans ce cas on fait un return sans aucune valeur
}
#+end_src

*** Appel

Utilisation de la fonction.

/Elles s'utilisent seules et ne peuvent affecter un emplacement memoire./

#+begin_src c
nomFonction(argument1, ..., argument2);
#+end_src

** RECURSIVITE

Les fonctions recurrentes : fonction qui s'appelle elle-meme.

*IMPORTANT!* Dans une fonction recurrente il faut une condition d'arret.

*** Exemple :

   #+begin_src c
   float recurrence(int n) {
      if (n == 0) return 1;         // Condition d'arret
      return n * recurrence(--1);   // Recurrence
   }
   #+end_src

*** Avec operateur ternaire :

   #+begin_src c
   float recurrence(int n) {
      return (n == 0) ? 1 : n * recurrence(--n);
   }
   #+end_src

* LES STRUCTURES CONDITIONNELLES

** IF, ELSE, ELSE IF

*** IF

- *SI* expression *ALORS* instructions

#+begin_src c
if (expression)
{
    // instructions
}
#+end_src

*** ELSE

- *SI* expression *ALORS* instructions
- *SINON* instructions

#+begin_src c
if (expression)
{
    // instructions
}
else
{
    // instructions
}
#+end_src

*** ELSE IF

- *SI* expression *ALORS* instructions
- *SINON SI* expression *ALORS* instructions
- *SINON* instructions

#+begin_src c
if (expression)
{
    // instructions
}
else if (expression)
{
    // instructions
}
else
{
    // instructions
}
#+end_src

** BREAK

Permet de sortir d'une structure conditionnelle pendant son execution.

#+begin_src c
break;
#+end_src

** SWITCH

Lorsque l'on a un choix a valeur multiple, il est preferable d'utiliser un =switch= .

A venir...

* LES BOUCLES CONDITIONNELLES

Les boucles sont des blocs de code qui se repetent.

Elle necessitent une condition d'arret. Celle ci est definie dans la syntaxe.

** WHILE

Boucle d'instructions qui se repetent *TANT QUE* sa condition est vrai.

*Declaration :*

- *TANT QUE* l'expression =expression= est vraie
- *FAIRE* les instructions

#+begin_src c
while (expression) {

    /* Instructions */

}
#+end_src

/Si l'on souhaite sortir de la boucle a un moment donne en fonction de la valeur d'une variable,
 il faut declarer avec une valeur cette derniere en amont de la boucle./

*Exemple :*

#+begin_src c
int i = 0;
while (i < 5) {
    printf("i : %d\n", i++);
}
#+end_src

-> =0=

-> =1=

-> =2=

-> =3=

-> =4=

** DO WHILE

Boucle d'instructions qui se repetent *TANT QUE* sa condition est vrai mais qui execute son code avant tout.

*Declaration :*

- *FAIRE* les instructions
- *PUIS TANT QUE* l'expression =expression= est vraie
- *FAIRE* les instructions

#+begin_src c
do
{

    /* Instructions */

}
while (expression);
#+end_src

/Si l'on souhaite sortir de la boucle a un moment donne en fonction de la valeur d'une variable,
 il faut declarer avec une valeur cette derniere en amont de la boucle./

*Exemple :*

#+begin_src c
int i = 0;
do
{
    printf("i : %d\n", i++);
}
while (i < 5);
#+end_src

-> =0= (Se passe avant de lire la condition)

-> =1=

-> =2=

-> =3=

-> =4=

** FOR

Fonctionne comme un while mais permet aussi de :
- Realiser une instruction a l'entree de la boucle (generalement pour declarer ou definir un compteur)
- Une expression
- Une instruction de fin de boucle (generalement pour incrementer le compteur)

*Declaration :*

- *POUR* un compteur nomme =compteur= de type =type_cpt= ayant pour valeur de depart =valeur=
- *TANT QUE* l'expression =expression= est vrai
- *ALORS EN FIN DE BOUCLE* executer l'instruction =instruction_de_fin_boucle=

/Exception : Il est aussi possible d'ajouter plusieurs instructions separees par une virgule dans le for./

#+begin_src c
for (type_cpt compteur = valeur; expression; instruction_de_fin_boucle) {

    /* Instructions */

}
#+end_src

*Exemple :*

#+begin_src c
for (int i = 0; i < 10; i++) {
    printf("i : %d\n", i);
}
#+end_src

-> =0=

-> =1=

-> =2=

-> =3=

-> =4=

-> =5=

-> =6=

-> =7=

-> =8=

-> =9=

** BREAK

Tout comme pour les structures conditionnelles, permet de sortir d'une boucle pendant son execution.

#+begin_src c
break;
#+end_src

** LES BOUCLES INFINIES

Les boucles infinies sont des boucles dont l'on ne sort jamais jusqu'a la fin de l'execution du programme.

*** Avec WHILE

#+begin_src c
while (1) {

    /* Instructions a l'infinie */

}
#+end_src

*** Avec FOR

#+begin_src c
for (;;) {

    /* Instructions a l'infinie */

}
#+end_src

*** Vides

*Avec WHILE :*

#+begin_src c
while (1);
#+end_src

*Avec FOR :*

#+begin_src c
for (;;);
#+end_src

* LES POINTEURS

Variable contenant l'adresse d'une autre variable d'un type donne.

| Variable | Emplacement Memoire | Valeur         |
|----------+---------------------+----------------|
| var      | Adresse de var      | Valeur de var  |
| ptr      | Adresse de ptr      | Adresse de var |

*Syntaxe :*

| Syntaxe | Valeur         |
|---------+----------------|
| var     | Valeur de var  |
| &var    | Adresse de var |
|---------+----------------|
| ptr     | Adresse de var |
| *ptr    | Valeur de var  |
| &ptr    | Adresse de ptr |

** Declaration

Declaration d'une variable pointeur qui pointe sur l'adresse d'une variable.

#+begin_src c
type *pointeur = &addresseVariable;
#+end_src

** Valeur de la variable

Valeur de la variable pointee.

#+begin_src c
*pointeur
#+end_src

** Adresse de la variable

Adresse de la variable pointee.

#+begin_src c
pointeur
#+end_src

** Adresse du pointeur

Adresse du pointeur.

#+begin_src c
&pointeur
#+end_src

** Incrementation

A venir...

** Equivalence avec les crochets de tableau

~tableau[n]~ = ~*(tableau + n)~

*Attention aux parentheses!*

~tableau[n]~ != ~*tableau + n~ (Ici on interagit avec la valeur de l'element (0) du tableau)

** Soustraction d'adresses

* PORTEE DES VARIABLES

Une variable a une duree de vie, cette duree de vie est definie par sa portee, il s'agit de la zone dans laquelle une variable existe.

** Variables Globales
** Variables Locales
** Variables Externes

* ALLOCATION DYNAMIQUE

** Malloc

** Free

Malloc ne libere pas la memoire de lui meme la ou une allocation manuelle locale libere son emplacement a la fin de son bloc d'instructions. 

Free sert donc a liberer celle-ci.

* LEXIQUE

- API : Ensemble d'outils qui permettent de faire l'interface avec un service.
- IDE : Integrated Development Environnement (Environnement de Developpement Integre : Editeur de code avec Debogueur, Compilateur et plein d'outils, c'est notre environement de travail)
